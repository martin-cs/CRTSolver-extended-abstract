\section{Conclusion}
\label{section:conclusion}

%It works (on the limited set of benchmarks we have tried).
%
%It shows enough promise to be investigated further.
%We want to try to implement it in an actual solver.

In this work we have demonstrated the principle of using results from
the literature on Diophantine equations to build simple semi-decision
procedures for fragments of the theory of integers.
%
This gives results that match or exceed the state-of-the-art, despite
being significantly simpler and much less mature implementations.
%
We regard this as an effective proof-of-concept for the general approach.



There are many open questions and possible future directions for this work:

\begin{itemize}
%\item{We select primes sequentially, is that the best thing to do or are there better strategies given the encoding, the constants in the problem, how previous candidates have failed, etc.}
\item{Using ascending primes as moduli is correct but neglects various
  potential optimisations.  For example primes of the form $2^n \pm k$
  for small $k$ allow for efficient computation of bit-vector
  remainder.  Also some moduli simplify various powers, for example
  $x^4 mod\ 20$ can only have one of four possible values.}

\item{There are a range of approaches to encoding the modulo
  equations.
  %
  If bit-vectors are used there are questions about what
  bit-widths are used and how often modulo reductions are performed.
  There are a range of techniques used to optimise the performance of
  cryptographic primitives that might be used.
  %
  Alternatively the theory of finite fields in cvc5 might be an option.}
  
\item{The selection of candidates can likely be improved through
  caching partially successful and unsuccessful candidates.
  Alternatively computation of candidates could be treated as a
  separate non-linear sub-problem, similarly to the handling of
  quantifiers in MBQI.}

\item{The current algorithm takes minimal information from the failed
  candidates to inform the selection of a new modulus.  This is an
  area that can clearly be strengthened to better fit with the
  abstraction-refinement style of the algorithm.}

\item{Moving beyond equations, can this technique be extended to
  non-equalities ($\not=$), inequalities ($\leq$) and non-polynomial
  expressions?}
\end{itemize}
